{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ablem/OneDrive/Projetos/frontEnd-Estudo/ang-eCommerce/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, inject, Injectable, ElementRef, Renderer2, makeEnvironmentProviders, Directive, Input, Output, HostListener, Pipe } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nconst NGX_MASK_CONFIG = new InjectionToken('ngx-mask config');\nconst NEW_CONFIG = new InjectionToken('new ngx-mask config');\nconst INITIAL_CONFIG = new InjectionToken('initial ngx-mask config');\nconst initialConfig = {\n  suffix: '',\n  prefix: '',\n  thousandSeparator: ' ',\n  decimalMarker: ['.', ','],\n  clearIfNotMatch: false,\n  showTemplate: false,\n  showMaskTyped: false,\n  placeHolderCharacter: '_',\n  dropSpecialCharacters: true,\n  hiddenInput: undefined,\n  shownMaskExpression: '',\n  separatorLimit: '',\n  allowNegativeNumbers: false,\n  validation: true,\n  // eslint-disable-next-line @typescript-eslint/quotes\n  specialCharacters: ['-', '/', '(', ')', '.', ':', ' ', '+', ',', '@', '[', ']', '\"', \"'\"],\n  leadZeroDateTime: false,\n  triggerOnMaskChange: false,\n  maskFilled: new EventEmitter(),\n  patterns: {\n    '0': {\n      pattern: new RegExp('\\\\d')\n    },\n    '9': {\n      pattern: new RegExp('\\\\d'),\n      optional: true\n    },\n    X: {\n      pattern: new RegExp('\\\\d'),\n      symbol: '*'\n    },\n    A: {\n      pattern: new RegExp('[a-zA-Z0-9]')\n    },\n    S: {\n      pattern: new RegExp('[a-zA-Z]')\n    },\n    U: {\n      pattern: new RegExp('[A-Z]')\n    },\n    L: {\n      pattern: new RegExp('[a-z]')\n    },\n    d: {\n      pattern: new RegExp('\\\\d')\n    },\n    m: {\n      pattern: new RegExp('\\\\d')\n    },\n    M: {\n      pattern: new RegExp('\\\\d')\n    },\n    H: {\n      pattern: new RegExp('\\\\d')\n    },\n    h: {\n      pattern: new RegExp('\\\\d')\n    },\n    s: {\n      pattern: new RegExp('\\\\d')\n    }\n  }\n};\nconst timeMasks = ['Hh:m0:s0', 'Hh:m0', 'm0:s0'];\nconst withoutValidation = ['percent', 'Hh', 's0', 'm0', 'separator', 'd0/M0/0000', 'd0/M0', 'd0', 'M0'];\nlet NgxMaskApplierService = /*#__PURE__*/(() => {\n  class NgxMaskApplierService {\n    constructor() {\n      this._config = inject(NGX_MASK_CONFIG);\n      this.dropSpecialCharacters = this._config.dropSpecialCharacters;\n      this.hiddenInput = this._config.hiddenInput;\n      this.clearIfNotMatch = this._config.clearIfNotMatch;\n      this.specialCharacters = this._config.specialCharacters;\n      this.patterns = this._config.patterns;\n      this.prefix = this._config.prefix;\n      this.suffix = this._config.suffix;\n      this.thousandSeparator = this._config.thousandSeparator;\n      this.decimalMarker = this._config.decimalMarker;\n      this.showMaskTyped = this._config.showMaskTyped;\n      this.placeHolderCharacter = this._config.placeHolderCharacter;\n      this.validation = this._config.validation;\n      this.separatorLimit = this._config.separatorLimit;\n      this.allowNegativeNumbers = this._config.allowNegativeNumbers;\n      this.leadZeroDateTime = this._config.leadZeroDateTime;\n      this._shift = new Set();\n      this.maskExpression = '';\n      this.actualValue = '';\n      this.shownMaskExpression = '';\n      this._formatWithSeparators = (str, thousandSeparatorChar, decimalChars, precision) => {\n        let x = [];\n        let decimalChar = '';\n        if (Array.isArray(decimalChars)) {\n          const regExp = new RegExp(decimalChars.map(v => '[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v).join('|'));\n          x = str.split(regExp);\n          decimalChar = str.match(regExp)?.[0] ?? '';\n        } else {\n          x = str.split(decimalChars);\n          decimalChar = decimalChars;\n        }\n        const decimals = x.length > 1 ? `${decimalChar}${x[1]}` : '';\n        let res = x[0] ?? '';\n        const separatorLimit = this.separatorLimit.replace(/\\s/g, '');\n        if (separatorLimit && +separatorLimit) {\n          if (res[0] === '-') {\n            res = `-${res.slice(1, res.length).slice(0, separatorLimit.length)}`;\n          } else {\n            res = res.slice(0, separatorLimit.length);\n          }\n        }\n        const rgx = /(\\d+)(\\d{3})/;\n        while (thousandSeparatorChar && rgx.test(res)) {\n          res = res.replace(rgx, '$1' + thousandSeparatorChar + '$2');\n        }\n        if (precision === undefined) {\n          return res + decimals;\n        } else if (precision === 0) {\n          return res;\n        }\n        return res + decimals.substring(0, precision + 1);\n      };\n      this.percentage = str => {\n        return Number(str) >= 0 && Number(str) <= 100;\n      };\n      this.getPrecision = maskExpression => {\n        const x = maskExpression.split('.');\n        if (x.length > 1) {\n          return Number(x[x.length - 1]);\n        }\n        return Infinity;\n      };\n      this.checkAndRemoveSuffix = inputValue => {\n        for (let i = this.suffix?.length - 1; i >= 0; i--) {\n          const substr = this.suffix.substring(i, this.suffix?.length);\n          if (inputValue.includes(substr) && i !== this.suffix?.length - 1 && (i - 1 < 0 || !inputValue.includes(this.suffix.substring(i - 1, this.suffix?.length)))) {\n            return inputValue.replace(substr, '');\n          }\n        }\n        return inputValue;\n      };\n      this.checkInputPrecision = (inputValue, precision, decimalMarker) => {\n        if (precision < Infinity) {\n          // TODO need think about decimalMarker\n          if (Array.isArray(decimalMarker)) {\n            const marker = decimalMarker.find(dm => dm !== this.thousandSeparator);\n            // eslint-disable-next-line no-param-reassign\n            decimalMarker = marker ? marker : decimalMarker[0];\n          }\n          const precisionRegEx = new RegExp(this._charToRegExpExpression(decimalMarker) + `\\\\d{${precision}}.*$`);\n          const precisionMatch = inputValue.match(precisionRegEx);\n          const precisionMatchLength = (precisionMatch && precisionMatch[0]?.length) ?? 0;\n          if (precisionMatchLength - 1 > precision) {\n            const diff = precisionMatchLength - 1 - precision;\n            // eslint-disable-next-line no-param-reassign\n            inputValue = inputValue.substring(0, inputValue.length - diff);\n          }\n          if (precision === 0 && this._compareOrIncludes(inputValue[inputValue.length - 1], decimalMarker, this.thousandSeparator)) {\n            // eslint-disable-next-line no-param-reassign\n            inputValue = inputValue.substring(0, inputValue.length - 1);\n          }\n        }\n        return inputValue;\n      };\n    }\n    applyMaskWithPattern(inputValue, maskAndPattern) {\n      const [mask, customPattern] = maskAndPattern;\n      this.customPattern = customPattern;\n      return this.applyMask(inputValue, mask);\n    }\n    applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-explicit-any\n    cb = () => {}) {\n      if (!maskExpression || typeof inputValue !== 'string') {\n        return '';\n      }\n      let cursor = 0;\n      let result = '';\n      let multi = false;\n      let backspaceShift = false;\n      let shift = 1;\n      let stepBack = false;\n      if (inputValue.slice(0, this.prefix.length) === this.prefix) {\n        // eslint-disable-next-line no-param-reassign\n        inputValue = inputValue.slice(this.prefix.length, inputValue.length);\n      }\n      if (!!this.suffix && inputValue?.length > 0) {\n        // eslint-disable-next-line no-param-reassign\n        inputValue = this.checkAndRemoveSuffix(inputValue);\n      }\n      const inputArray = inputValue.toString().split('');\n      if (maskExpression === 'IP') {\n        const valuesIP = inputValue.split('.');\n        this.ipError = this._validIP(valuesIP);\n        // eslint-disable-next-line no-param-reassign\n        maskExpression = '099.099.099.099';\n      }\n      const arr = [];\n      for (let i = 0; i < inputValue.length; i++) {\n        if (inputValue[i]?.match('\\\\d')) {\n          arr.push(inputValue[i] ?? '');\n        }\n      }\n      if (maskExpression === 'CPF_CNPJ') {\n        this.cpfCnpjError = arr.length !== 11 && arr.length !== 14;\n        if (arr.length > 11) {\n          // eslint-disable-next-line no-param-reassign\n          maskExpression = '00.000.000/0000-00';\n        } else {\n          // eslint-disable-next-line no-param-reassign\n          maskExpression = '000.000.000-00';\n        }\n      }\n      if (maskExpression.startsWith('percent')) {\n        if (inputValue.match('[a-z]|[A-Z]') ||\n        // eslint-disable-next-line no-useless-escape\n        inputValue.match(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,\\/.]/)) {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = this._stripToDecimal(inputValue);\n          const precision = this.getPrecision(maskExpression);\n          // eslint-disable-next-line no-param-reassign\n          inputValue = this.checkInputPrecision(inputValue, precision, this.decimalMarker);\n        }\n        if (inputValue.indexOf('.') > 0 && !this.percentage(inputValue.substring(0, inputValue.indexOf('.')))) {\n          const base = inputValue.substring(0, inputValue.indexOf('.') - 1);\n          // eslint-disable-next-line no-param-reassign\n          inputValue = `${base}${inputValue.substring(inputValue.indexOf('.'), inputValue.length)}`;\n        }\n        if (this.percentage(inputValue)) {\n          result = inputValue;\n        } else {\n          result = inputValue.substring(0, inputValue.length - 1);\n        }\n      } else if (maskExpression.startsWith('separator')) {\n        if (inputValue.match('[wа-яА-Я]') || inputValue.match('[ЁёА-я]') || inputValue.match('[a-z]|[A-Z]') || inputValue.match(/[-@#!$%\\\\^&*()_£¬'+|~=`{}\\]:\";<>.?/]/) || inputValue.match('[^A-Za-z0-9,]')) {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = this._stripToDecimal(inputValue);\n        }\n        // eslint-disable-next-line no-param-reassign\n        inputValue = inputValue.length > 1 && inputValue[0] === '0' && inputValue[1] !== this.thousandSeparator && !this._compareOrIncludes(inputValue[1], this.decimalMarker, this.thousandSeparator) && !backspaced ? inputValue.slice(0, inputValue.length - 1) : inputValue;\n        if (backspaced) {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = this._compareOrIncludes(inputValue[inputValue.length - 1], this.decimalMarker, this.thousandSeparator) ? inputValue.slice(0, inputValue.length - 1) : inputValue;\n        }\n        // TODO: we had different rexexps here for the different cases... but tests dont seam to bother - check this\n        //  separator: no COMMA, dot-sep: no SPACE, COMMA OK, comma-sep: no SPACE, COMMA OK\n        const thousandSeparatorCharEscaped = this._charToRegExpExpression(this.thousandSeparator);\n        let invalidChars = '@#!$%^&*()_+|~=`{}\\\\[\\\\]:\\\\s,\\\\.\";<>?\\\\/'.replace(thousandSeparatorCharEscaped, '');\n        //.replace(decimalMarkerEscaped, '');\n        if (Array.isArray(this.decimalMarker)) {\n          for (const marker of this.decimalMarker) {\n            invalidChars = invalidChars.replace(this._charToRegExpExpression(marker), '');\n          }\n        } else {\n          invalidChars = invalidChars.replace(this._charToRegExpExpression(this.decimalMarker), '');\n        }\n        const invalidCharRegexp = new RegExp('[' + invalidChars + ']');\n        if (inputValue.match(invalidCharRegexp) || inputValue.length === 1 && this._compareOrIncludes(inputValue, this.decimalMarker, this.thousandSeparator)) {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = inputValue.substring(0, inputValue.length - 1);\n        }\n        const precision = this.getPrecision(maskExpression);\n        // eslint-disable-next-line no-param-reassign\n        inputValue = this.checkInputPrecision(inputValue, precision, this.decimalMarker);\n        const strForSep = inputValue.replace(new RegExp(thousandSeparatorCharEscaped, 'g'), '');\n        result = this._formatWithSeparators(strForSep, this.thousandSeparator, this.decimalMarker, precision);\n        const commaShift = result.indexOf(',') - inputValue.indexOf(',');\n        const shiftStep = result.length - inputValue.length;\n        if (shiftStep > 0 && result[position] !== ',') {\n          backspaceShift = true;\n          let _shift = 0;\n          do {\n            this._shift.add(position + _shift);\n            _shift++;\n          } while (_shift < shiftStep);\n        } else if (commaShift !== 0 && position > 0 && !(result.indexOf(',') >= position && position > 3) || !(result.indexOf('.') >= position && position > 3) && shiftStep <= 0) {\n          this._shift.clear();\n          backspaceShift = true;\n          shift = shiftStep;\n          // eslint-disable-next-line no-param-reassign\n          position += shiftStep;\n          this._shift.add(position);\n        } else {\n          this._shift.clear();\n        }\n      } else {\n        for (\n        // eslint-disable-next-line\n        let i = 0, inputSymbol = inputArray[0]; i < inputArray.length; i++, inputSymbol = inputArray[i] ?? '') {\n          if (cursor === maskExpression.length) {\n            break;\n          }\n          if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? '') && maskExpression[cursor + 1] === '?') {\n            result += inputSymbol;\n            cursor += 2;\n          } else if (maskExpression[cursor + 1] === '*' && multi && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? '')) {\n            result += inputSymbol;\n            cursor += 3;\n            multi = false;\n          } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? '') && maskExpression[cursor + 1] === '*') {\n            result += inputSymbol;\n            multi = true;\n          } else if (maskExpression[cursor + 1] === '?' && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2] ?? '')) {\n            result += inputSymbol;\n            cursor += 3;\n          } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor] ?? '')) {\n            if (maskExpression[cursor] === 'H') {\n              if (Number(inputSymbol) > 2) {\n                cursor += 1;\n                this._shiftStep(maskExpression, cursor, inputArray.length);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 'h') {\n              if (result === '2' && Number(inputSymbol) > 3) {\n                cursor += 1;\n                i--;\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 'm') {\n              if (Number(inputSymbol) > 5) {\n                cursor += 1;\n                this._shiftStep(maskExpression, cursor, inputArray.length);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 's') {\n              if (Number(inputSymbol) > 5) {\n                cursor += 1;\n                this._shiftStep(maskExpression, cursor, inputArray.length);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            const daysCount = 31;\n            if (maskExpression[cursor] === 'd') {\n              if (Number(inputSymbol) > 3 && this.leadZeroDateTime || Number(inputValue.slice(cursor, cursor + 2)) > daysCount || inputValue[cursor + 1] === '/') {\n                cursor += 1;\n                this._shiftStep(maskExpression, cursor, inputArray.length);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 'M') {\n              const monthsCount = 12;\n              // mask without day\n              const withoutDays = cursor === 0 && (Number(inputSymbol) > 2 || Number(inputValue.slice(cursor, cursor + 2)) > monthsCount || inputValue[cursor + 1] === '/');\n              // day<10 && month<12 for input\n              const day1monthInput = inputValue.slice(cursor - 3, cursor - 1).includes('/') && (inputValue[cursor - 2] === '/' && Number(inputValue.slice(cursor - 1, cursor + 1)) > monthsCount && inputValue[cursor] !== '/' || inputValue[cursor] === '/' || inputValue[cursor - 3] === '/' && Number(inputValue.slice(cursor - 2, cursor)) > monthsCount && inputValue[cursor - 1] !== '/' || inputValue[cursor - 1] === '/');\n              // 10<day<31 && month<12 for input\n              const day2monthInput = Number(inputValue.slice(cursor - 3, cursor - 1)) <= daysCount && !inputValue.slice(cursor - 3, cursor - 1).includes('/') && inputValue[cursor - 1] === '/' && (Number(inputValue.slice(cursor, cursor + 2)) > monthsCount || inputValue[cursor + 1] === '/');\n              // day<10 && month<12 for paste whole data\n              const day1monthPaste = Number(inputValue.slice(cursor - 3, cursor - 1)) > daysCount && !inputValue.slice(cursor - 3, cursor - 1).includes('/') && !inputValue.slice(cursor - 2, cursor).includes('/') && Number(inputValue.slice(cursor - 2, cursor)) > monthsCount;\n              // 10<day<31 && month<12 for paste whole data\n              const day2monthPaste = Number(inputValue.slice(cursor - 3, cursor - 1)) <= daysCount && !inputValue.slice(cursor - 3, cursor - 1).includes('/') && inputValue[cursor - 1] !== '/' && Number(inputValue.slice(cursor - 1, cursor + 1)) > monthsCount;\n              if (Number(inputSymbol) > 1 && this.leadZeroDateTime || withoutDays || day1monthInput || day2monthInput || day1monthPaste || day2monthPaste) {\n                cursor += 1;\n                this._shiftStep(maskExpression, cursor, inputArray.length);\n                i--;\n                if (this.leadZeroDateTime) {\n                  result += '0';\n                }\n                continue;\n              }\n            }\n            result += inputSymbol;\n            cursor++;\n          } else if (inputSymbol === ' ' && maskExpression[cursor] === ' ') {\n            result += inputSymbol;\n            cursor++;\n          } else if (this.specialCharacters.indexOf(maskExpression[cursor] ?? '') !== -1) {\n            result += maskExpression[cursor];\n            cursor++;\n            this._shiftStep(maskExpression, cursor, inputArray.length);\n            i--;\n          } else if (this.specialCharacters.indexOf(inputSymbol) > -1 && this.patterns[maskExpression[cursor] ?? ''] && this.patterns[maskExpression[cursor] ?? '']?.optional) {\n            if (!!inputArray[cursor] && maskExpression !== '099.099.099.099' && maskExpression !== '000.000.000-00' && maskExpression !== '00.000.000/0000-00' && !maskExpression.match(/^9+\\.0+$/)) {\n              result += inputArray[cursor];\n            }\n            cursor++;\n            i--;\n          } else if (this.maskExpression[cursor + 1] === '*' && this._findSpecialChar(this.maskExpression[cursor + 2] ?? '') && this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] && multi) {\n            cursor += 3;\n            result += inputSymbol;\n          } else if (this.maskExpression[cursor + 1] === '?' && this._findSpecialChar(this.maskExpression[cursor + 2] ?? '') && this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] && multi) {\n            cursor += 3;\n            result += inputSymbol;\n          } else if (this.showMaskTyped && this.specialCharacters.indexOf(inputSymbol) < 0 && inputSymbol !== this.placeHolderCharacter) {\n            stepBack = true;\n          }\n        }\n      }\n      if (result.length + 1 === maskExpression.length && this.specialCharacters.indexOf(maskExpression[maskExpression.length - 1] ?? '') !== -1) {\n        result += maskExpression[maskExpression.length - 1];\n      }\n      let newPosition = position + 1;\n      while (this._shift.has(newPosition)) {\n        shift++;\n        newPosition++;\n      }\n      let actualShift = justPasted && !maskExpression.startsWith('separator') ? cursor : this._shift.has(position) ? shift : 0;\n      if (stepBack) {\n        actualShift--;\n      }\n      cb(actualShift, backspaceShift);\n      if (shift < 0) {\n        this._shift.clear();\n      }\n      let onlySpecial = false;\n      if (backspaced) {\n        onlySpecial = inputArray.every(char => this.specialCharacters.includes(char));\n      }\n      let res = `${this.prefix}${onlySpecial ? '' : result}${this.suffix}`;\n      if (result.length === 0) {\n        res = `${this.prefix}${result}`;\n      }\n      return res;\n    }\n    _findSpecialChar(inputSymbol) {\n      return this.specialCharacters.find(val => val === inputSymbol);\n    }\n    _checkSymbolMask(inputSymbol, maskSymbol) {\n      this.patterns = this.customPattern ? this.customPattern : this.patterns;\n      return (this.patterns[maskSymbol]?.pattern && this.patterns[maskSymbol]?.pattern.test(inputSymbol)) ?? false;\n    }\n    _stripToDecimal(str) {\n      return str.split('').filter((i, idx) => {\n        const isDecimalMarker = typeof this.decimalMarker === 'string' ? i === this.decimalMarker :\n        // TODO (inepipenko) use utility type\n        this.decimalMarker.includes(i);\n        return i.match('^-?\\\\d') || i === this.thousandSeparator || isDecimalMarker || i === '-' && idx === 0 && this.allowNegativeNumbers;\n      }).join('');\n    }\n    _charToRegExpExpression(char) {\n      // if (Array.isArray(char)) {\n      // \treturn char.map((v) => ('[\\\\^$.|?*+()'.indexOf(v) >= 0 ? `\\\\${v}` : v)).join('|');\n      // }\n      if (char) {\n        const charsToEscape = '[\\\\^$.|?*+()';\n        return char === ' ' ? '\\\\s' : charsToEscape.indexOf(char) >= 0 ? `\\\\${char}` : char;\n      }\n      return char;\n    }\n    _shiftStep(maskExpression, cursor, inputLength) {\n      const shiftStep = /[*?]/g.test(maskExpression.slice(0, cursor)) ? inputLength : cursor;\n      this._shift.add(shiftStep + this.prefix.length || 0);\n    }\n    _compareOrIncludes(value, comparedValue, excludedValue) {\n      return Array.isArray(comparedValue) ? comparedValue.filter(v => v !== excludedValue).includes(value) : value === comparedValue;\n    }\n    _validIP(valuesIP) {\n      return !(valuesIP.length === 4 && !valuesIP.some((value, index) => {\n        if (valuesIP.length !== index + 1) {\n          return value === '' || Number(value) > 255;\n        }\n        return value === '' || Number(value.substring(0, 3)) > 255;\n      }));\n    }\n  }\n  NgxMaskApplierService.ɵfac = function NgxMaskApplierService_Factory(t) {\n    return new (t || NgxMaskApplierService)();\n  };\n  NgxMaskApplierService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxMaskApplierService,\n    factory: NgxMaskApplierService.ɵfac\n  });\n  return NgxMaskApplierService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMaskService = /*#__PURE__*/(() => {\n  class NgxMaskService extends NgxMaskApplierService {\n    constructor() {\n      super(...arguments);\n      this.isNumberValue = false;\n      this.maskIsShown = '';\n      this.selStart = null;\n      this.selEnd = null;\n      /**\n       * Whether we are currently in writeValue function, in this case when applying the mask we don't want to trigger onChange function,\n       * since writeValue should be a one way only process of writing the DOM value based on the Angular model value.\n       */\n      this.writingValue = false;\n      this.maskChanged = false;\n      this.triggerOnMaskChange = false;\n      // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-explicit-any\n      this.onChange = _ => {};\n      this.document = inject(DOCUMENT);\n      this._config = inject(NGX_MASK_CONFIG);\n      this._elementRef = inject(ElementRef, {\n        optional: true\n      });\n      this._renderer = inject(Renderer2, {\n        optional: true\n      });\n    }\n    // eslint-disable-next-line complexity\n    applyMask(inputValue, maskExpression, position = 0, justPasted = false, backspaced = false,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-explicit-any\n    cb = () => {}) {\n      if (!maskExpression) {\n        return inputValue !== this.actualValue ? this.actualValue : inputValue;\n      }\n      this.maskIsShown = this.showMaskTyped ? this.showMaskInInput() : '';\n      if (this.maskExpression === 'IP' && this.showMaskTyped) {\n        this.maskIsShown = this.showMaskInInput(inputValue || '#');\n      }\n      if (this.maskExpression === 'CPF_CNPJ' && this.showMaskTyped) {\n        this.maskIsShown = this.showMaskInInput(inputValue || '#');\n      }\n      if (!inputValue && this.showMaskTyped) {\n        this.formControlResult(this.prefix);\n        return this.prefix + this.maskIsShown;\n      }\n      const getSymbol = !!inputValue && typeof this.selStart === 'number' ? inputValue[this.selStart] ?? '' : '';\n      let newInputValue = '';\n      if (this.hiddenInput !== undefined && !this.writingValue) {\n        let actualResult = this.actualValue.split('');\n        // eslint-disable  @typescript-eslint/no-unused-expressions\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        inputValue !== '' && actualResult.length ? typeof this.selStart === 'number' && typeof this.selEnd === 'number' ? inputValue.length > actualResult.length ? actualResult.splice(this.selStart, 0, getSymbol) : inputValue.length < actualResult.length ? actualResult.length - inputValue.length === 1 ? actualResult.splice(this.selStart - 1, 1) : actualResult.splice(this.selStart, this.selEnd - this.selStart) : null : null : actualResult = [];\n        if (this.showMaskTyped) {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = this.removeMask(inputValue);\n        }\n        // eslint-enable  @typescript-eslint/no-unused-expressions\n        newInputValue = this.actualValue.length && actualResult.length <= inputValue.length ? this.shiftTypedSymbols(actualResult.join('')) : inputValue;\n      }\n      if (this.showMaskTyped) {\n        // eslint-disable-next-line no-param-reassign\n        inputValue = this.removeMask(inputValue);\n      }\n      newInputValue = Boolean(newInputValue) && newInputValue.length ? newInputValue : inputValue;\n      const result = super.applyMask(newInputValue, maskExpression, position, justPasted, backspaced, cb);\n      this.actualValue = this.getActualValue(result);\n      // handle some separator implications:\n      // a.) adjust decimalMarker default (. -> ,) if thousandSeparator is a dot\n      if (this.thousandSeparator === '.' && this.decimalMarker === '.') {\n        this.decimalMarker = ',';\n      }\n      // b) remove decimal marker from list of special characters to mask\n      if (this.maskExpression.startsWith('separator') && this.dropSpecialCharacters === true) {\n        this.specialCharacters = this.specialCharacters.filter(item => !this._compareOrIncludes(item, this.decimalMarker, this.thousandSeparator) //item !== this.decimalMarker, // !\n        );\n      }\n\n      this.formControlResult(result);\n      if (!this.showMaskTyped) {\n        if (this.hiddenInput) {\n          return result && result.length ? this.hideInput(result, this.maskExpression) : result;\n        }\n        return result;\n      }\n      const resLen = result.length;\n      const prefNmask = this.prefix + this.maskIsShown;\n      if (this.maskExpression.includes('H')) {\n        const countSkipedSymbol = this._numberSkipedSymbols(result);\n        return result + prefNmask.slice(resLen + countSkipedSymbol);\n      } else if (this.maskExpression === 'IP' || this.maskExpression === 'CPF_CNPJ') {\n        return result + prefNmask;\n      }\n      return result + prefNmask.slice(resLen);\n    }\n    // get the number of characters that were shifted\n    _numberSkipedSymbols(value) {\n      const regex = /(^|\\D)(\\d\\D)/g;\n      let match = regex.exec(value);\n      let countSkipedSymbol = 0;\n      while (match != null) {\n        countSkipedSymbol += 1;\n        match = regex.exec(value);\n      }\n      return countSkipedSymbol;\n    }\n    applyValueChanges(position, justPasted, backspaced,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-explicit-any\n    cb = () => {}) {\n      const formElement = this._elementRef?.nativeElement;\n      if (!formElement) {\n        return;\n      }\n      formElement.value = this.applyMask(formElement.value, this.maskExpression, position, justPasted, backspaced, cb);\n      if (formElement === this._getActiveElement()) {\n        return;\n      }\n      this.clearIfNotMatchFn();\n    }\n    hideInput(inputValue, maskExpression) {\n      return inputValue.split('').map((curr, index) => {\n        if (this.patterns && this.patterns[maskExpression[index] ?? ''] && this.patterns[maskExpression[index] ?? '']?.symbol) {\n          return this.patterns[maskExpression[index] ?? '']?.symbol;\n        }\n        return curr;\n      }).join('');\n    }\n    // this function is not necessary, it checks result against maskExpression\n    getActualValue(res) {\n      const compare = res.split('').filter((symbol, i) => {\n        const maskChar = this.maskExpression[i] ?? '';\n        return this._checkSymbolMask(symbol, maskChar) || this.specialCharacters.includes(maskChar) && symbol === maskChar;\n      });\n      if (compare.join('') === res) {\n        return compare.join('');\n      }\n      return res;\n    }\n    shiftTypedSymbols(inputValue) {\n      let symbolToReplace = '';\n      const newInputValue = inputValue && inputValue.split('').map((currSymbol, index) => {\n        if (this.specialCharacters.includes(inputValue[index + 1] ?? '') && inputValue[index + 1] !== this.maskExpression[index + 1]) {\n          symbolToReplace = currSymbol;\n          return inputValue[index + 1];\n        }\n        if (symbolToReplace.length) {\n          const replaceSymbol = symbolToReplace;\n          symbolToReplace = '';\n          return replaceSymbol;\n        }\n        return currSymbol;\n      }) || [];\n      return newInputValue.join('');\n    }\n    /**\n     * Convert number value to string\n     * 3.1415 -> '3.1415'\n     * 1e-7 -> '0.0000001'\n     */\n    numberToString(value) {\n      if (!value && value !== 0) {\n        return String(value);\n      }\n      return Number(value).toLocaleString('fullwide', {\n        useGrouping: false,\n        maximumFractionDigits: 20\n      });\n    }\n    showMaskInInput(inputVal) {\n      if (this.showMaskTyped && !!this.shownMaskExpression) {\n        if (this.maskExpression.length !== this.shownMaskExpression.length) {\n          throw new Error('Mask expression must match mask placeholder length');\n        } else {\n          return this.shownMaskExpression;\n        }\n      } else if (this.showMaskTyped) {\n        if (inputVal) {\n          if (this.maskExpression === 'IP') {\n            return this._checkForIp(inputVal);\n          }\n          if (this.maskExpression === 'CPF_CNPJ') {\n            return this._checkForCpfCnpj(inputVal);\n          }\n        }\n        return this.maskExpression.replace(/\\w/g, this.placeHolderCharacter);\n      }\n      return '';\n    }\n    clearIfNotMatchFn() {\n      const formElement = this._elementRef?.nativeElement;\n      if (!formElement) {\n        return;\n      }\n      if (this.clearIfNotMatch && this.prefix.length + this.maskExpression.length + this.suffix.length !== formElement.value.replace(/_/g, '').length) {\n        this.formElementProperty = ['value', ''];\n        this.applyMask(formElement.value, this.maskExpression);\n      }\n    }\n    set formElementProperty([name, value]) {\n      if (!this._renderer || !this._elementRef) {\n        return;\n      }\n      Promise.resolve().then(() => this._renderer?.setProperty(this._elementRef?.nativeElement, name, value));\n    }\n    checkSpecialCharAmount(mask) {\n      const chars = mask.split('').filter(item => this._findSpecialChar(item));\n      return chars.length;\n    }\n    removeMask(inputValue) {\n      return this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.specialCharacters.concat('_').concat(this.placeHolderCharacter));\n    }\n    _checkForIp(inputVal) {\n      if (inputVal === '#') {\n        return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n      }\n      const arr = [];\n      for (let i = 0; i < inputVal.length; i++) {\n        const value = inputVal[i] ?? '';\n        if (!value) {\n          continue;\n        }\n        if (value.match('\\\\d')) {\n          arr.push(value);\n        }\n      }\n      if (arr.length <= 3) {\n        return `${this.placeHolderCharacter}.${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n      }\n      if (arr.length > 3 && arr.length <= 6) {\n        return `${this.placeHolderCharacter}.${this.placeHolderCharacter}`;\n      }\n      if (arr.length > 6 && arr.length <= 9) {\n        return this.placeHolderCharacter;\n      }\n      if (arr.length > 9 && arr.length <= 12) {\n        return '';\n      }\n      return '';\n    }\n    _checkForCpfCnpj(inputVal) {\n      const cpf = `${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n      const cnpj = `${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `.${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `/${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}${this.placeHolderCharacter}` + `-${this.placeHolderCharacter}${this.placeHolderCharacter}`;\n      if (inputVal === '#') {\n        return cpf;\n      }\n      const arr = [];\n      for (let i = 0; i < inputVal.length; i++) {\n        const value = inputVal[i] ?? '';\n        if (!value) {\n          continue;\n        }\n        if (value.match('\\\\d')) {\n          arr.push(value);\n        }\n      }\n      if (arr.length <= 3) {\n        return cpf.slice(arr.length, cpf.length);\n      }\n      if (arr.length > 3 && arr.length <= 6) {\n        return cpf.slice(arr.length + 1, cpf.length);\n      }\n      if (arr.length > 6 && arr.length <= 9) {\n        return cpf.slice(arr.length + 2, cpf.length);\n      }\n      if (arr.length > 9 && arr.length < 11) {\n        return cpf.slice(arr.length + 3, cpf.length);\n      }\n      if (arr.length === 11) {\n        return '';\n      }\n      if (arr.length === 12) {\n        if (inputVal.length === 17) {\n          return cnpj.slice(16, cnpj.length);\n        }\n        return cnpj.slice(15, cnpj.length);\n      }\n      if (arr.length > 12 && arr.length <= 14) {\n        return cnpj.slice(arr.length + 4, cnpj.length);\n      }\n      return '';\n    }\n    /**\n     * Recursively determine the current active element by navigating the Shadow DOM until the Active Element is found.\n     */\n    _getActiveElement(document = this.document) {\n      const shadowRootEl = document?.activeElement?.shadowRoot;\n      if (!shadowRootEl?.activeElement) {\n        return document.activeElement;\n      } else {\n        return this._getActiveElement(shadowRootEl);\n      }\n    }\n    /**\n     * Propogates the input value back to the Angular model by triggering the onChange function. It won't do this if writingValue\n     * is true. If that is true it means we are currently in the writeValue function, which is supposed to only update the actual\n     * DOM element based on the Angular model value. It should be a one way process, i.e. writeValue should not be modifying the Angular\n     * model value too. Therefore, we don't trigger onChange in this scenario.\n     * @param inputValue the current form input value\n     */\n    formControlResult(inputValue) {\n      if (this.writingValue || !this.triggerOnMaskChange && this.maskChanged) {\n        this.maskChanged = false;\n        return;\n      }\n      if (Array.isArray(this.dropSpecialCharacters)) {\n        this.onChange(this._toNumber(this._removeMask(this._removeSuffix(this._removePrefix(inputValue)), this.dropSpecialCharacters)));\n      } else if (this.dropSpecialCharacters) {\n        this.onChange(this._toNumber(this._checkSymbols(inputValue)));\n      } else {\n        this.onChange(this._removeSuffix(inputValue));\n      }\n    }\n    _toNumber(value) {\n      if (!this.isNumberValue || value === '') {\n        return value;\n      }\n      const num = Number(value);\n      return Number.isNaN(num) ? value : num;\n    }\n    _removeMask(value, specialCharactersForRemove) {\n      return value ? value.replace(this._regExpForRemove(specialCharactersForRemove), '') : value;\n    }\n    _removePrefix(value) {\n      if (!this.prefix) {\n        return value;\n      }\n      return value ? value.replace(this.prefix, '') : value;\n    }\n    _removeSuffix(value) {\n      if (!this.suffix) {\n        return value;\n      }\n      return value ? value.replace(this.suffix, '') : value;\n    }\n    _retrieveSeparatorValue(result) {\n      return this._removeMask(this._removeSuffix(this._removePrefix(result)), this.specialCharacters);\n    }\n    _regExpForRemove(specialCharactersForRemove) {\n      return new RegExp(specialCharactersForRemove.map(item => `\\\\${item}`).join('|'), 'gi');\n    }\n    _replaceDecimalMarkerToDot(value) {\n      const markers = Array.isArray(this.decimalMarker) ? this.decimalMarker : [this.decimalMarker];\n      return value.replace(this._regExpForRemove(markers), '.');\n    }\n    _checkSymbols(result) {\n      if (result === '') {\n        return result;\n      }\n      const separatorPrecision = this._retrieveSeparatorPrecision(this.maskExpression);\n      const separatorValue = this._replaceDecimalMarkerToDot(this._retrieveSeparatorValue(result));\n      if (!this.isNumberValue) {\n        return separatorValue;\n      }\n      if (separatorPrecision) {\n        if (result === this.decimalMarker) {\n          return null;\n        }\n        return this._checkPrecision(this.maskExpression, separatorValue);\n      } else {\n        return Number(separatorValue);\n      }\n    }\n    // TODO should think about helpers or separting decimal precision to own property\n    _retrieveSeparatorPrecision(maskExpretion) {\n      const matcher = maskExpretion.match(new RegExp(`^separator\\\\.([^d]*)`));\n      return matcher ? Number(matcher[1]) : null;\n    }\n    _checkPrecision(separatorExpression, separatorValue) {\n      if (separatorExpression.indexOf('2') > 0) {\n        return Number(separatorValue).toFixed(2);\n      }\n      return Number(separatorValue);\n    }\n  }\n  NgxMaskService.ɵfac = /* @__PURE__ */function () {\n    let ɵNgxMaskService_BaseFactory;\n    return function NgxMaskService_Factory(t) {\n      return (ɵNgxMaskService_BaseFactory || (ɵNgxMaskService_BaseFactory = i0.ɵɵgetInheritedFactory(NgxMaskService)))(t || NgxMaskService);\n    };\n  }();\n  NgxMaskService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxMaskService,\n    factory: NgxMaskService.ɵfac\n  });\n  return NgxMaskService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @internal\n */\nfunction _configFactory() {\n  const initConfig = inject(INITIAL_CONFIG);\n  const configValue = inject(NEW_CONFIG);\n  return configValue instanceof Function ? {\n    ...initConfig,\n    ...configValue()\n  } : {\n    ...initConfig,\n    ...configValue\n  };\n}\nfunction provideNgxMask(configValue) {\n  return [{\n    provide: NEW_CONFIG,\n    useValue: configValue\n  }, {\n    provide: INITIAL_CONFIG,\n    useValue: initialConfig\n  }, {\n    provide: NGX_MASK_CONFIG,\n    useFactory: _configFactory\n  }, NgxMaskService];\n}\nfunction provideEnvironmentNgxMask(configValue) {\n  return makeEnvironmentProviders(provideNgxMask(configValue));\n}\nlet NgxMaskDirective = /*#__PURE__*/(() => {\n  class NgxMaskDirective {\n    constructor() {\n      // eslint-disable-next-line @angular-eslint/no-input-rename\n      this.maskExpression = '';\n      this.specialCharacters = [];\n      this.patterns = {};\n      this.prefix = '';\n      this.suffix = '';\n      this.thousandSeparator = ' ';\n      this.decimalMarker = '.';\n      this.dropSpecialCharacters = null;\n      this.hiddenInput = null;\n      this.showMaskTyped = null;\n      this.placeHolderCharacter = null;\n      this.shownMaskExpression = null;\n      this.showTemplate = null;\n      this.clearIfNotMatch = null;\n      this.validation = null;\n      this.separatorLimit = null;\n      this.allowNegativeNumbers = null;\n      this.leadZeroDateTime = null;\n      this.triggerOnMaskChange = null;\n      this.maskFilled = new EventEmitter();\n      this._maskValue = '';\n      this._position = null;\n      this._maskExpressionArray = [];\n      this._justPasted = false;\n      this.document = inject(DOCUMENT);\n      this._maskService = inject(NgxMaskService, {\n        self: true\n      });\n      this._config = inject(NGX_MASK_CONFIG);\n      // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-explicit-any\n      this.onChange = _ => {};\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      this.onTouch = () => {};\n    }\n    ngOnChanges(changes) {\n      const {\n        maskExpression,\n        specialCharacters,\n        patterns,\n        prefix,\n        suffix,\n        thousandSeparator,\n        decimalMarker,\n        dropSpecialCharacters,\n        hiddenInput,\n        showMaskTyped,\n        placeHolderCharacter,\n        shownMaskExpression,\n        showTemplate,\n        clearIfNotMatch,\n        validation,\n        separatorLimit,\n        allowNegativeNumbers,\n        leadZeroDateTime,\n        triggerOnMaskChange\n      } = changes;\n      if (maskExpression) {\n        if (maskExpression.currentValue !== maskExpression.previousValue && !maskExpression.firstChange) {\n          this._maskService.maskChanged = true;\n        }\n        if (maskExpression.currentValue && maskExpression.currentValue.split('||').length > 1) {\n          this._maskExpressionArray = maskExpression.currentValue.split('||').sort((a, b) => {\n            return a.length - b.length;\n          });\n          this._setMask();\n        } else {\n          this._maskExpressionArray = [];\n          this._maskValue = maskExpression.currentValue || '';\n          this._maskService.maskExpression = this._maskValue;\n        }\n      }\n      if (specialCharacters) {\n        if (!specialCharacters.currentValue || !Array.isArray(specialCharacters.currentValue)) {\n          return;\n        } else {\n          this._maskService.specialCharacters = specialCharacters.currentValue || [];\n        }\n      }\n      // Only overwrite the mask available patterns if a pattern has actually been passed in\n      if (patterns && patterns.currentValue) {\n        this._maskService.patterns = patterns.currentValue;\n      }\n      if (prefix) {\n        this._maskService.prefix = prefix.currentValue;\n      }\n      if (suffix) {\n        this._maskService.suffix = suffix.currentValue;\n      }\n      if (thousandSeparator) {\n        this._maskService.thousandSeparator = thousandSeparator.currentValue;\n      }\n      if (decimalMarker) {\n        this._maskService.decimalMarker = decimalMarker.currentValue;\n      }\n      if (dropSpecialCharacters) {\n        this._maskService.dropSpecialCharacters = dropSpecialCharacters.currentValue;\n      }\n      if (hiddenInput) {\n        this._maskService.hiddenInput = hiddenInput.currentValue;\n      }\n      if (showMaskTyped) {\n        this._maskService.showMaskTyped = showMaskTyped.currentValue;\n      }\n      if (placeHolderCharacter) {\n        this._maskService.placeHolderCharacter = placeHolderCharacter.currentValue;\n      }\n      if (shownMaskExpression) {\n        this._maskService.shownMaskExpression = shownMaskExpression.currentValue;\n      }\n      if (showTemplate) {\n        this._maskService.showTemplate = showTemplate.currentValue;\n      }\n      if (clearIfNotMatch) {\n        this._maskService.clearIfNotMatch = clearIfNotMatch.currentValue;\n      }\n      if (validation) {\n        this._maskService.validation = validation.currentValue;\n      }\n      if (separatorLimit) {\n        this._maskService.separatorLimit = separatorLimit.currentValue;\n      }\n      if (allowNegativeNumbers) {\n        this._maskService.allowNegativeNumbers = allowNegativeNumbers.currentValue;\n        if (this._maskService.allowNegativeNumbers) {\n          this._maskService.specialCharacters = this._maskService.specialCharacters.filter(c => c !== '-');\n        }\n      }\n      if (leadZeroDateTime) {\n        this._maskService.leadZeroDateTime = leadZeroDateTime.currentValue;\n      }\n      if (triggerOnMaskChange) {\n        this._maskService.triggerOnMaskChange = triggerOnMaskChange.currentValue;\n      }\n      this._applyMask();\n    }\n    // eslint-disable-next-line complexity\n    validate({\n      value\n    }) {\n      if (!this._maskService.validation || !this._maskValue) {\n        return null;\n      }\n      if (this._maskService.ipError) {\n        return this._createValidationError(value);\n      }\n      if (this._maskService.cpfCnpjError) {\n        return this._createValidationError(value);\n      }\n      if (this._maskValue.startsWith('separator')) {\n        return null;\n      }\n      if (withoutValidation.includes(this._maskValue)) {\n        return null;\n      }\n      if (this._maskService.clearIfNotMatch) {\n        return null;\n      }\n      if (timeMasks.includes(this._maskValue)) {\n        return this._validateTime(value);\n      }\n      if (value && value.toString().length >= 1) {\n        let counterOfOpt = 0;\n        for (const key in this._maskService.patterns) {\n          if (this._maskService.patterns[key]?.optional) {\n            if (this._maskValue.indexOf(key) !== this._maskValue.lastIndexOf(key)) {\n              const opt = this._maskValue.split('').filter(i => i === key).join('');\n              counterOfOpt += opt.length;\n            } else if (this._maskValue.indexOf(key) !== -1) {\n              counterOfOpt++;\n            }\n            if (this._maskValue.indexOf(key) !== -1 && value.toString().length >= this._maskValue.indexOf(key)) {\n              return null;\n            }\n            if (counterOfOpt === this._maskValue.length) {\n              return null;\n            }\n          }\n        }\n        if (this._maskValue.indexOf('{') === 1 && value.toString().length === this._maskValue.length + Number((this._maskValue.split('{')[1] ?? '').split('}')[0]) - 4) {\n          return null;\n        }\n        if (this._maskValue.indexOf('*') === 1 || this._maskValue.indexOf('?') === 1) {\n          return null;\n        } else if (this._maskValue.indexOf('*') > 1 && value.toString().length < this._maskValue.indexOf('*') || this._maskValue.indexOf('?') > 1 && value.toString().length < this._maskValue.indexOf('?') || this._maskValue.indexOf('{') === 1) {\n          return this._createValidationError(value);\n        }\n        if (this._maskValue.indexOf('*') === -1 || this._maskValue.indexOf('?') === -1) {\n          const length = this._maskService.dropSpecialCharacters ? this._maskValue.length - this._maskService.checkSpecialCharAmount(this._maskValue) - counterOfOpt : this._maskValue.length - counterOfOpt;\n          if (value.toString().length < length) {\n            return this._createValidationError(value);\n          }\n        }\n      }\n      if (value) {\n        this.maskFilled.emit();\n        return null;\n      }\n      return null;\n    }\n    onPaste() {\n      this._justPasted = true;\n    }\n    onModelChange(value) {\n      // on form reset we need to update the actualValue\n      if ((value === '' || value === null || value === undefined) && this._maskService.actualValue) {\n        this._maskService.actualValue = this._maskService.getActualValue('');\n      }\n    }\n    onInput(e) {\n      const el = e.target;\n      this._inputValue = el.value;\n      this._setMask();\n      if (!this._maskValue) {\n        this.onChange(el.value);\n        return;\n      }\n      let position = el.selectionStart === 1 ? el.selectionStart + this._maskService.prefix.length : el.selectionStart;\n      let caretShift = 0;\n      let backspaceShift = false;\n      this._maskService.applyValueChanges(position, this._justPasted, this._code === 'Backspace' || this._code === 'Delete', (shift, _backspaceShift) => {\n        this._justPasted = false;\n        caretShift = shift;\n        backspaceShift = _backspaceShift;\n      });\n      // only set the selection if the element is active\n      if (this._getActiveElement() !== el) {\n        return;\n      }\n      // update position after applyValueChanges to prevent cursor on wrong position when it has an array of maskExpression\n      if (this._maskExpressionArray.length) {\n        position = el.selectionStart === 1 ? el.selectionStart + this._maskService.prefix.length : el.selectionStart;\n      }\n      this._position = this._position === 1 && this._inputValue.length === 1 ? null : this._position;\n      let positionToApply = this._position ? this._inputValue.length + position + caretShift : position + (this._code === 'Backspace' && !backspaceShift ? 0 : caretShift);\n      if (positionToApply > this._getActualInputLength()) {\n        positionToApply = this._getActualInputLength();\n      }\n      if (positionToApply < 0) {\n        positionToApply = 0;\n      }\n      el.setSelectionRange(positionToApply, positionToApply);\n      this._position = null;\n    }\n    onBlur() {\n      if (this._maskValue) {\n        this._maskService.clearIfNotMatchFn();\n      }\n      this.onTouch();\n    }\n    onClick(e) {\n      if (!this._maskValue) {\n        return;\n      }\n      const el = e.target;\n      const posStart = 0;\n      const posEnd = 0;\n      if (el !== null && el.selectionStart !== null && el.selectionStart === el.selectionEnd && el.selectionStart > this._maskService.prefix.length &&\n      // eslint-disable-next-line\n      e.keyCode !== 38) {\n        if (this._maskService.showMaskTyped) {\n          // We are showing the mask in the input\n          this._maskService.maskIsShown = this._maskService.showMaskInInput();\n          if (el.setSelectionRange && this._maskService.prefix + this._maskService.maskIsShown === el.value) {\n            // the input ONLY contains the mask, so position the cursor at the start\n            el.focus();\n            el.setSelectionRange(posStart, posEnd);\n          } else {\n            // the input contains some characters already\n            if (el.selectionStart > this._maskService.actualValue.length) {\n              // if the user clicked beyond our value's length, position the cursor at the end of our value\n              el.setSelectionRange(this._maskService.actualValue.length, this._maskService.actualValue.length);\n            }\n          }\n        }\n      }\n      const nextValue = el && (!el.value || el.value === this._maskService.prefix ? this._maskService.prefix + this._maskService.maskIsShown : el.value);\n      /** Fix of cursor position jumping to end in most browsers no matter where cursor is inserted onFocus */\n      if (el && el.value !== nextValue) {\n        el.value = nextValue;\n      }\n      /** fix of cursor position with prefix when mouse click occur */\n      if (el && (el.selectionStart || el.selectionEnd) <= this._maskService.prefix.length) {\n        el.selectionStart = this._maskService.prefix.length;\n        return;\n      }\n      /** select only inserted text */\n      if (el && el.selectionEnd > this._getActualInputLength()) {\n        el.selectionEnd = this._getActualInputLength();\n      }\n    }\n    // eslint-disable-next-line complexity\n    onKeyDown(e) {\n      if (!this._maskValue) {\n        return;\n      }\n      this._code = e.code ? e.code : e.key;\n      const el = e.target;\n      this._inputValue = el.value;\n      this._setMask();\n      if (e.keyCode === 38) {\n        e.preventDefault();\n      }\n      if (e.keyCode === 37 || e.keyCode === 8 || e.keyCode === 46) {\n        if (e.keyCode === 8 && el.value.length === 0) {\n          el.selectionStart = el.selectionEnd;\n        }\n        if (e.keyCode === 8 && el.selectionStart !== 0) {\n          // If specialChars is false, (shouldn't ever happen) then set to the defaults\n          this.specialCharacters = this.specialCharacters?.length ? this.specialCharacters : this._config.specialCharacters;\n          if (this.prefix.length > 1 && el.selectionStart <= this.prefix.length) {\n            el.setSelectionRange(this.prefix.length, el.selectionEnd);\n          } else {\n            if (this._inputValue.length !== el.selectionStart && el.selectionStart !== 1) {\n              while (this.specialCharacters.includes((this._inputValue[el.selectionStart - 1] ?? '').toString()) && (this.prefix.length >= 1 && el.selectionStart > this.prefix.length || this.prefix.length === 0)) {\n                el.setSelectionRange(el.selectionStart - 1, el.selectionEnd);\n              }\n            }\n          }\n        }\n        this.checkSelectionOnDeletion(el);\n        if (this._maskService.prefix.length && el.selectionStart <= this._maskService.prefix.length && el.selectionEnd <= this._maskService.prefix.length) {\n          e.preventDefault();\n        }\n        const cursorStart = el.selectionStart;\n        if (e.keyCode === 8 && !el.readOnly && cursorStart === 0 && el.selectionEnd === el.value.length && el.value.length !== 0) {\n          this._position = this._maskService.prefix ? this._maskService.prefix.length : 0;\n          this._maskService.applyMask(this._maskService.prefix, this._maskService.maskExpression, this._position);\n        }\n      }\n      if (!!this.suffix && this.suffix.length > 1 && this._inputValue.length - this.suffix.length < el.selectionStart) {\n        el.setSelectionRange(this._inputValue.length - this.suffix.length, this._inputValue.length);\n      } else if (e.keyCode === 65 && e.ctrlKey || e.keyCode === 65 && e.metaKey // Cmd + A (Mac)\n      ) {\n        el.setSelectionRange(0, this._getActualInputLength());\n        e.preventDefault();\n      }\n      this._maskService.selStart = el.selectionStart;\n      this._maskService.selEnd = el.selectionEnd;\n    }\n    /** It writes the value in the input */\n    writeValue(inputValue) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (typeof inputValue === 'object' && inputValue !== null && 'value' in inputValue) {\n          if ('disable' in inputValue) {\n            _this.setDisabledState(Boolean(inputValue.disable));\n          }\n          // eslint-disable-next-line no-param-reassign\n          inputValue = inputValue.value;\n        }\n        if (typeof inputValue === 'number' || _this._maskValue.startsWith('separator')) {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = _this._maskService.numberToString(inputValue);\n          if (!Array.isArray(_this.decimalMarker)) {\n            // eslint-disable-next-line no-param-reassign\n            inputValue = _this.decimalMarker !== '.' ? inputValue.replace('.', _this.decimalMarker) : inputValue;\n          }\n          _this._maskService.isNumberValue = true;\n        }\n        if (typeof inputValue !== 'string') {\n          // eslint-disable-next-line no-param-reassign\n          inputValue = '';\n        }\n        _this._inputValue = inputValue;\n        _this._setMask();\n        if (inputValue && _this._maskService.maskExpression || _this._maskService.maskExpression && (_this._maskService.prefix || _this._maskService.showMaskTyped)) {\n          // Let the service we know we are writing value so that triggering onChange function won't happen during applyMask\n          _this._maskService.writingValue = true;\n          _this._maskService.formElementProperty = ['value', _this._maskService.applyMask(inputValue, _this._maskService.maskExpression)];\n          // Let the service know we've finished writing value\n          _this._maskService.writingValue = false;\n        } else {\n          _this._maskService.formElementProperty = ['value', inputValue];\n        }\n        _this._inputValue = inputValue;\n      })();\n    }\n    registerOnChange(fn) {\n      this._maskService.onChange = this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouch = fn;\n    }\n    _getActiveElement(document = this.document) {\n      const shadowRootEl = document?.activeElement?.shadowRoot;\n      if (!shadowRootEl?.activeElement) {\n        return document.activeElement;\n      } else {\n        return this._getActiveElement(shadowRootEl);\n      }\n    }\n    checkSelectionOnDeletion(el) {\n      el.selectionStart = Math.min(Math.max(this.prefix.length, el.selectionStart), this._inputValue.length - this.suffix.length);\n      el.selectionEnd = Math.min(Math.max(this.prefix.length, el.selectionEnd), this._inputValue.length - this.suffix.length);\n    }\n    /** It disables the input element */\n    setDisabledState(isDisabled) {\n      this._maskService.formElementProperty = ['disabled', isDisabled];\n    }\n    _repeatPatternSymbols(maskExp) {\n      return maskExp.match(/{[0-9]+}/) && maskExp.split('').reduce((accum, currVal, index) => {\n        this._start = currVal === '{' ? index : this._start;\n        if (currVal !== '}') {\n          return this._maskService._findSpecialChar(currVal) ? accum + currVal : accum;\n        }\n        this._end = index;\n        const repeatNumber = Number(maskExp.slice(this._start + 1, this._end));\n        const replaceWith = new Array(repeatNumber + 1).join(maskExp[this._start - 1]);\n        return accum + replaceWith;\n      }, '') || maskExp;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _applyMask() {\n      this._maskService.maskExpression = this._repeatPatternSymbols(this._maskValue || '');\n      this._maskService.formElementProperty = ['value', this._maskService.applyMask(this._inputValue, this._maskService.maskExpression)];\n    }\n    _validateTime(value) {\n      const rowMaskLen = this._maskValue.split('').filter(s => s !== ':').length;\n      if (!value) {\n        return null; // Don't validate empty values to allow for optional form control\n      }\n\n      if (+(value[value.length - 1] ?? -1) === 0 && value.length < rowMaskLen || value.length <= rowMaskLen - 2) {\n        return this._createValidationError(value);\n      }\n      return null;\n    }\n    _getActualInputLength() {\n      return this._maskService.actualValue.length || this._maskService.actualValue.length + this._maskService.prefix.length;\n    }\n    _createValidationError(actualValue) {\n      return {\n        mask: {\n          requiredMask: this._maskValue,\n          actualValue\n        }\n      };\n    }\n    _setMask() {\n      if (this._maskExpressionArray.length > 0) {\n        this._maskExpressionArray.some(mask => {\n          const test = this._maskService.removeMask(this._inputValue)?.length <= this._maskService.removeMask(mask)?.length;\n          if (this._inputValue && test) {\n            this._maskValue = mask;\n            this.maskExpression = mask;\n            this._maskService.maskExpression = mask;\n            return test;\n          } else {\n            const expression = this._maskExpressionArray[this._maskExpressionArray.length - 1] ?? '';\n            this._maskValue = this.maskExpression = this._maskService.maskExpression = expression;\n          }\n        });\n      }\n    }\n  }\n  NgxMaskDirective.ɵfac = function NgxMaskDirective_Factory(t) {\n    return new (t || NgxMaskDirective)();\n  };\n  NgxMaskDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxMaskDirective,\n    selectors: [[\"input\", \"mask\", \"\"], [\"textarea\", \"mask\", \"\"]],\n    hostBindings: function NgxMaskDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"paste\", function NgxMaskDirective_paste_HostBindingHandler() {\n          return ctx.onPaste();\n        })(\"ngModelChange\", function NgxMaskDirective_ngModelChange_HostBindingHandler($event) {\n          return ctx.onModelChange($event);\n        })(\"input\", function NgxMaskDirective_input_HostBindingHandler($event) {\n          return ctx.onInput($event);\n        })(\"blur\", function NgxMaskDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"click\", function NgxMaskDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"keydown\", function NgxMaskDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      maskExpression: [\"mask\", \"maskExpression\"],\n      specialCharacters: \"specialCharacters\",\n      patterns: \"patterns\",\n      prefix: \"prefix\",\n      suffix: \"suffix\",\n      thousandSeparator: \"thousandSeparator\",\n      decimalMarker: \"decimalMarker\",\n      dropSpecialCharacters: \"dropSpecialCharacters\",\n      hiddenInput: \"hiddenInput\",\n      showMaskTyped: \"showMaskTyped\",\n      placeHolderCharacter: \"placeHolderCharacter\",\n      shownMaskExpression: \"shownMaskExpression\",\n      showTemplate: \"showTemplate\",\n      clearIfNotMatch: \"clearIfNotMatch\",\n      validation: \"validation\",\n      separatorLimit: \"separatorLimit\",\n      allowNegativeNumbers: \"allowNegativeNumbers\",\n      leadZeroDateTime: \"leadZeroDateTime\",\n      triggerOnMaskChange: \"triggerOnMaskChange\"\n    },\n    outputs: {\n      maskFilled: \"maskFilled\"\n    },\n    exportAs: [\"mask\", \"ngxMask\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: NgxMaskDirective,\n      multi: true\n    }, {\n      provide: NG_VALIDATORS,\n      useExisting: NgxMaskDirective,\n      multi: true\n    }, NgxMaskService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return NgxMaskDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxMaskPipe = /*#__PURE__*/(() => {\n  class NgxMaskPipe {\n    constructor() {\n      this.defaultOptions = {};\n      this._maskService = inject(NgxMaskService);\n    }\n    transform(value, mask, {\n      patterns,\n      ...config\n    } = {}) {\n      const currentConfig = {\n        maskExpression: mask,\n        ...this.defaultOptions,\n        ...config,\n        patterns: {\n          ...this._maskService.patterns,\n          ...patterns\n        }\n      };\n      Object.entries(currentConfig).forEach(([key, value]) => {\n        //eslint-disable-next-line  @typescript-eslint/no-explicit-any\n        this._maskService[key] = value;\n      });\n      return this._maskService.applyMask(`${value}`, mask);\n    }\n  }\n  NgxMaskPipe.ɵfac = function NgxMaskPipe_Factory(t) {\n    return new (t || NgxMaskPipe)();\n  };\n  NgxMaskPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"mask\",\n    type: NgxMaskPipe,\n    pure: true,\n    standalone: true\n  });\n  return NgxMaskPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n(function () {\n  if (!commonjsGlobal.KeyboardEvent) {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    commonjsGlobal.KeyboardEvent = function (_eventType, _init) {};\n  }\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_CONFIG, NEW_CONFIG, NGX_MASK_CONFIG, NgxMaskApplierService, NgxMaskDirective, NgxMaskPipe, NgxMaskService, initialConfig, provideEnvironmentNgxMask, provideNgxMask, timeMasks, withoutValidation };\n//# sourceMappingURL=ngx-mask.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}